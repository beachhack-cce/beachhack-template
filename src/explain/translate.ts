/**
 * ZeroHour – human-readable explanations from detected failures.
 */

import { DetectedFailure } from '../types';

export function failureScenario(f: DetectedFailure): string {
  const scenarios: Record<string, string> = {
    A1: 'An attacker or bug sends invalid input to the API; it reaches business logic and causes a crash or corrupt state.',
    A2: 'Client validation is bypassed; malformed or malicious payloads hit the backend and break assumptions.',
    A3: 'User-controlled numbers overflow, become NaN, or go negative; calculations or quotas fail.',
    A4: 'Large offset or unbounded list is requested; memory or CPU spikes and the service degrades or crashes.',
    A5: 'An exception is thrown; the empty catch hides it and the process continues in an invalid state.',
    A6: 'A client is modified or the API is called directly; business rules are bypassed (e.g. price, eligibility).',
    A7: 'A sensitive feature is enabled on the client without server check; inconsistent or insecure behavior.',
    B1: 'An unauthenticated request hits a protected route; data or actions are exposed.',
    B2: 'Secrets are read from code or config; credentials are compromised (repo, build, or runtime).',
    B3: 'A non-admin or non-owner calls admin/payment endpoint; privilege escalation or unauthorized charges.',
    B4: 'Repeated requests to an expensive endpoint exhaust CPU, memory, or downstream; service becomes unavailable.',
    B5: 'A malicious or oversized file is uploaded; storage or execution is abused.',
    B6: 'A user changes an ID in the request and accesses or modifies another user’s resource (IDOR).',
    C1: 'An awaited call rejects; the error propagates and is unhandled; process may crash.',
    C2: 'A promise rejects; without .catch(), unhandledRejection is emitted and the process can exit.',
    C3: 'A remote service hangs; the request never completes and connections or event loop block.',
    C4: 'A failing dependency is retried indefinitely; load and failure cascade.',
    C5: 'An uncaught error in a request handler crashes the server or leaks stack traces.',
    C6: 'A promise rejects and no handler runs; Node may terminate.',
    D1: 'One of several writes fails; the database is left in an inconsistent state.',
    D2: 'An update partially applies; on failure there is no rollback and state is inconsistent.',
    D3: 'A write fails; the error is not handled and state or process is left inconsistent.',
    D4: 'Duplicate values are inserted for a “unique” field; integrity and business logic break.',
    D5: 'Two requests update the same counter or balance; one update is lost (race condition).',
    E1: 'The API fails; the UI stays in loading state and the user sees no error.',
    E2: 'The request fails; the app does not show an error and the user is left confused.',
    E3: 'The server rejects the action; the UI already showed success and is now wrong.',
    E4: 'The user double-clicks submit; two requests are sent and duplicate records or charges occur.',
    E5: 'The API returns 4xx/5xx; the client treats it as success and shows wrong data or flow.',
    F1: 'The service is reachable from the network; attack surface is larger than intended.',
    F2: 'Debug or dev mode runs in production; info leaks or performance degrades.',
    F3: 'Sensitive cookies or data are sent over HTTP; they can be intercepted.',
    F4: 'Production uses the same config as dev; secrets or behavior are wrong.',
    F5: 'Secrets in the repo are pushed or forked; credentials are exposed.',
  };
  return scenarios[f.ruleId] ?? 'This pattern can lead to failure under load, abuse, or invalid input.';
}

export function fixNowBullets(f: DetectedFailure): string[] {
  const fixes: Record<string, string[]> = {
    A1: ['Add server-side validation (schema/zod/joi) for all request body, params, and query.', 'Reject invalid input with 400 before business logic.'],
    A2: ['Implement the same validation on the backend as on the client.', 'Never trust client-side checks for security or integrity.'],
    A3: ['Validate and bound numeric input (min, max, type).', 'Use safe arithmetic or bigint where overflow is possible.'],
    A4: ['Enforce a maximum limit and default for list/offset parameters.', 'Validate range before querying.'],
    A5: ['Log the error in catch blocks.', 'Re-throw or return a controlled error response instead of swallowing.'],
    A6: ['Move business rules (price, eligibility, permissions) to the backend.', 'Use frontend only for UX, not enforcement.'],
    A7: ['Enforce feature flags on the server.', 'Gate sensitive features by server-side checks.'],
    B1: ['Add authentication middleware to all protected routes.', 'Return 401 for unauthenticated requests.'],
    B2: ['Remove secrets from source; use env vars or a secret manager.', 'Add the file to .gitignore and rotate any exposed credentials.'],
    B3: ['Add authorization checks (role, ownership) on admin and payment routes.', 'Return 403 when the user is not allowed.'],
    B4: ['Add rate limiting (per IP or per user) on expensive endpoints.', 'Return 429 when limit is exceeded.'],
    B5: ['Validate file type (allowlist) and size before processing.', 'Store uploads outside web root and scan if needed.'],
    B6: ['Verify resource ownership or permission before returning or updating.', 'Use session/user context, not only request IDs.'],
    C1: ['Wrap async handlers in try/catch and handle errors.', 'Return a safe response or re-throw to a global handler.'],
    C2: ['Add .catch() to every promise chain.', 'Or use async/await with try/catch.'],
    C3: ['Set a timeout on all HTTP/client requests.', 'Use AbortController or library timeout option.'],
    C4: ['Add circuit breaker or max retries with backoff.', 'Fail fast when dependency is down.'],
    C5: ['Register a global error middleware (e.g. 4-arg (err, req, res, next)).', 'Log and return a generic 500 without stack to clients.'],
    C6: ['Add .catch() or try/catch for all promise-returning code.', 'Ensure no unhandled rejections.'],
    D1: ['Wrap multi-step writes in a transaction.', 'Commit only when all steps succeed; rollback on error.'],
    D2: ['Use a transaction for partial updates or implement explicit rollback.', 'On failure, revert or compensate.'],
    D3: ['Wrap DB writes in try/catch and handle errors.', 'Return a clear error and do not leave state half-updated.'],
    D4: ['Add a unique constraint or index on the field in the DB/schema.', 'Handle duplicate key errors in code.'],
    D5: ['Use a transaction or “select for update” for counter/balance updates.', 'Serialize concurrent updates.'],
    E1: ['Add error state and UI (message, retry) when the request fails.', 'Use an ErrorBoundary for React.'],
    E2: ['Handle fetch/axios errors and show a user-visible message.', 'Use .catch() or isError and render error UI.'],
    E3: ['On API failure, revert optimistic update and show error.', 'Use onError/onSettled to reset state.'],
    E4: ['Disable the submit button while the request is in flight.', 'Optionally debounce submit to avoid double clicks.'],
    E5: ['Check response.ok or response.status before using the body.', 'Handle 4xx/5xx with error UI or retry.'],
    F1: ['Bind to 127.0.0.1 or a specific interface unless you need external access.', 'Use a reverse proxy for public exposure.'],
    F2: ['Disable debug in production; use NODE_ENV or env-specific config.', 'Never enable debug in prod.'],
    F3: ['Use HTTPS in production and set secure cookie flags.', 'Redirect HTTP to HTTPS.'],
    F4: ['Split config by NODE_ENV or env name.', 'Load only the config for the current environment.'],
    F5: ['Remove secrets from the repo; use env or secret manager.', 'Add .env to .gitignore and rotate exposed secrets.'],
  };
  return fixes[f.ruleId] ?? ['Review this code path and add validation, error handling, or guards as appropriate.'];
}

export function failureTitle(f: DetectedFailure): string {
  const titles: Record<string, string> = {
    A1: 'Missing input validation on public API',
    A2: 'Trusting client-side validation only',
    A3: 'Arithmetic on user input without bounds',
    A4: 'Missing boundary checks',
    A5: 'Silent failures (empty catch)',
    A6: 'Business rules only in frontend',
    A7: 'Client-side feature flags only',
    B1: 'Missing authentication middleware',
    B2: 'Hardcoded or plaintext secrets',
    B3: 'Missing authorization on admin/payment routes',
    B4: 'No rate limiting on expensive endpoints',
    B5: 'File uploads without validation',
    B6: 'Direct object access without ownership check',
    C1: 'Async without try/catch',
    C2: 'Promises without .catch()',
    C3: 'Network calls without timeouts',
    C4: 'Retries without circuit breakers',
    C5: 'Missing global error handler',
    C6: 'Unhandled promise rejections',
    D1: 'Multi-step DB writes without transactions',
    D2: 'Partial updates without rollback',
    D3: 'DB writes without error handling',
    D4: 'Missing uniqueness/integrity constraints',
    D5: 'Concurrent writes without guards',
    E1: 'Infinite loaders without error UI',
    E2: 'API failures hidden from users',
    E3: 'Optimistic UI without rollback',
    E4: 'Forms without debounce/disable',
    E5: 'Blind trust in backend success',
    F1: 'Services exposed on 0.0.0.0',
    F2: 'Debug enabled in production',
    F3: 'Missing HTTPS/secure flags',
    F4: 'Missing env-specific configs',
    F5: 'Secrets committed to repo',
  };
  return titles[f.ruleId] ?? `Rule ${f.ruleId}: ${f.detectionExplanation}`;
}
